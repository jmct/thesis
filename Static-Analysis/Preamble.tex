In lazy languages evaluation should only occur when necessary. This apparently
sensible rule can be at odds with the goals of performance through parallelism:
if we have parallel processing resources, we wish to use them to do as much work
as possible to shorten execution time \citep{tremblay1995impact}.

Call-by-need semantics forces the compiler to take care in deciding which
sub-expressions can safely be executed in parallel.  Having a simple
parallelisation heuristic such as `compute all arguments to functions in
parallel' can alter the semantics of a non-strict language, introducing
non-termination or runtime errors that would not have occurred during a
sequential execution.

The process of determining which arguments are required for a function is known
as \emph{strictness analysis} \citep{mycroft1980theory}. Since the early 1980's
such analysis has been widely used for reducing the overheads of laziness
\tocite{spjDemand or Sergey's paper}.

Therefore, before we can run our automatically parallelised programs, we must
develop methods and techniques for the compiler to \emph{find} and
\emph{express} the parallelism that is implicit in our programs. Strictness
analysis is suitable in aiding this task but care must be taken in choosing
a specific analysis to use.

This chapter is concerned with studying the alternative analyses and the
trade-offs that are inherent in the differing approaches. A survey of the
concepts and development of strictness analysis will inform our choice of
analysis and allow us to understand the drawbacks and limits of our chosen
method.

\subsection*{Plan of the Chapter}


